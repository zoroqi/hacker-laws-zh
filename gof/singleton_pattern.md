---
aliases:
- Singleton pattern
- 单例模式
category:
- 设计模式
name: Singleton pattern
tags:
- 设计模式/创建范例
- 单例模式
- 程序/范例
wiki: https://en.wikipedia.org/wiki/Singleton_pattern
zhname: 单例模式
zhwiki: https://zh.wikipedia.org/wiki/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F
id: 20221001230942_b4378ff31feb4319
date: "2022-10-01"
---

# 单例模式

保证一个类仅有一个实例，并提供一个访问它的全局访问点

适用性场景:

* 当类只能有一个实例而且客户可以从一个众所周知的访问点访问它时。
* 当这个唯一实例应该是通过子类化可扩展的，并且客户应该无需更改代码就能使用一个扩展的实例时。

效果:

1. 对唯一实例的受控访问因为Singleton类封装它的唯一实例，所以它可以严格的控制客户怎样以及何时访问它。
2. 缩小名空间Singleton模式是对全局变量的一种改进。它避免了那些存储唯一实例的全局变量污染名空间。
3. 允许对操作和表示的精化Singleton类可以有子类，而且用这个扩展类的实例来配置一个应用是很容易的。你可以用你所需要的类的实例在运行时刻配置应用。
4. 允许可变数目的实例这个模式使得你易于改变你的想法，并允许Singleton类的多个实例。此外，你可以用相同的方法来控制应用所使用的实例的数目。只有允许访问Singleton实例的操作需要改变。
5. 比类操作更灵活另一种封装单件功能的方式是使用类操作（即C++中的静态成员函数或者是Smalltalk中的类方法）。但这两种语言技术都难以改变设计以允许一个类有多个实例。此外，C++中的静态成员函数不是虚函数，因此子类不能多态的重定义它们。