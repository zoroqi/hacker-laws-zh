---
category:
- 代码的坏味道
aliases:
- Feature Envy
- 依恋情结
name: Feature Envy
zhname: 依恋情结
tags:
- 程序/范例
- 程序/设计
- 代码的坏味道
id: 20221125190645_e7637e3be3a742be
date: "2022-11-25"
---

# Feature Envy (依恋情结)

对象技术的全部要点在于：这是一种「将数据和加诸其上的操作行为包装在一起」 的技术。有一种经典气味是：函数对某个class的兴趣高过对自己所处之host class的兴趣。这种孺慕之情最通常的焦点便是数据。无数次经验里，我们看到某个函数 为了计算某值，从另一个对象那儿调用几乎半打的取值函数（getting method）。疗法显而易见：把这个函数移至另一个地点。你应该使用Move Method 把它 移到它该去的地方。有时候函数中只有一部分受这种依恋之苦，这时候你应该使用 Extract Method 把这一部分提炼到独立函数中，再使用Move Method 带它去它的梦中家园。

当然，并非所有情况都这么简单。一个函数往往会用上数个特性，那么它究竟该被置于何处呢？我们的原则是：判断哪个class拥有最多「被此函数使用」的数据，然后就把这个函数和那些数据摆在一起。如果先以Extract Method 将这个函数分解为数个较小函数并分别置放于不同地点，上述步骤也就比较容易完成了。

有数个复杂精巧的模式(patterns)破坏了这个规则。说起这个话题，「四巨头」[[设计模式README|GOF]]的Strategy 和Visitor立刻跳入我的脑海，Kent Beck 的 Self Delegation Beck也在此列。使用这些模式是为了对抗坏味道Divergent Change。最根本的原则是：将总是一起变化的东西放在一块儿。「数据」和「引用这些数据」的行为总是一起变化的，但也有例外。如果例外出现，我们就搬移那些行为，保持「变化只在一地发生」。Strategy 和Visitor『使你得以轻松修改函数行为，因为它们将少量需被覆写〔overridden）的行为隔离开来——当然也付出了「多一层间接性」的 代价
