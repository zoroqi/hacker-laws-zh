---
aliases:
- Flyweight pattern
- 享元模式
category:
- 设计模式
name: Flyweight pattern
tags:
- 设计模式/结构范例
- 享元模式
- 程序/范例
wiki: https://en.wikipedia.org/wiki/Flyweight_pattern
zhname: 享元模式
zhwiki: https://zh.wikipedia.org/wiki/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F
id: 20221001225556_fa5d62b51b33421b
date: "2022-10-01"
---

# 享元模式

运用共享技术有效地支持大量细粒度的对象

适用性场景:
* 一个应用程序使用了大量的对象。
* 完全由于使用大量的对象，造成很大的存储开销。
* 对象的大多数状态都可变为外部状态。
* 如果删除对象的外部状态，那么可以用相对较少的共享对象取代很多组对象。
* 应用程序不依赖于对象标识。由于Flyweight对象可以被共享，对于概念上明显有别的对象，标识测试将返回真值。

效果:

使用Flyweight模式时，传输、查找和/或计算外部状态都会产生运行时的开销，尤其当flyweight原先被存储为内部状态时。然而，空间上的节省抵消了这些开销。共享的flyweight越多，空间节省也就越大。

存储节约由以下几个因素决定：
* 因为共享，实例总数减少的数目
* 对象内部状态的平均数目
* 外部状态是计算的还是存储的

共享的Flyweight越多，存储节约也就越多。节约量随着共享状态的增多而增大。当对象使用大量的内部及外部状态，并且外部状态是计算出来的而非存储的时候，节约量将达到最大。所以，可以用两种方法来节约存储：用共享减少内部状态的消耗，用计算时间换取对外部状态的存储